

1. # meta http-equiv="refresh" content="5, https://www.baidu.com   5秒之后重定向，我们抓取后面这个网站。
2. 盗链接
    1. 防。设置一个中间键，检查META['HTTP_Referer']
* 中间键, 攻 - 'www.jd.com' in request.META['HTTP_Referer']
    1. https://ww.abc.com/video
    2. requests.get(url, headers={'Referer': 'https://www.abc.com/video'})
    3. https://www.abc.com/video/25436
3.并发编程
    1. 多线程 + GIL + 共享内存  （* io密集型）
    2. 多进程 + IPC(socket / pipe)
    3. 多进程 + 协程（微线程）  推荐   （* 暴力破解密码，计算密集型）
    4. 单线程 + 异步IO   （* io密集型）  推荐， 可以取代第一种

    * 异步 不阻塞
    * 同步 阻塞

# 使用多进程，对I/O 密集型任务的性能没有实质性的改善
# 多进程 可以利用CPU的多核特性，对计算密集型任务有用
# 对于网络爬虫这种I/O 密集型任务，最好的方式是单线程+ 异步I/O
# 所谓的异步i/0是非阻塞式的i/o操作，也就是在I/O操作时没有中断CPU
# 多线程编程担心  多个线程竞争资源，
# 为什么使用并发编程，1. 改善用户体验2. 提升性能。

4. 多线程编程担心什么 -- 多个线程竞争资源，并发数据访问，导致数据出错。
    * 解决方法，加锁，线程锁。
    * acquire() / release() 加锁 / 解锁
    * 如果多个线程获取锁的方式不正确，那么就有可能导致死锁（dead lock）
    * 加锁，就意味着线程要排队等待，相当于并发代码变成了串行执行。
    * 所有在写多线程的时候，可以尽量避开对资源的竞争
    * 一种做法就是通过ThreadLocal为线程绑定资源，让每个线程持有副本的资源。

5. 协程
    1. 一个线程里，两个子程序，相互协作，互相切换，叫协程序、
    2. 优点
        * 没有线程切换，协程极高的执行效率
        * 不需要多线程的锁机制，即没有资源竞争
        * Python对协程的支持是通过generator实现的。协程是生成器的消费者。
    3. 定义：
        1. 协程在一个线程中
        2. 协程是一个消费性的生成器
        3.两个函数在互不调用的情况下互相协作

6. 异步i/o
    1. 相当于开了个进程。
    2. 协程如何实现在单线程里面多并发的效果？ 其核心就是遇到 IO操作就切换，
    3. 那么怎么知道 IO 操作已完成，自动切换回去呢？回调


7. 作业
    1. yield from 语法，
    2. aiohttp 异步请求，异步io操作。
    3. 豆瓣电影网站分析